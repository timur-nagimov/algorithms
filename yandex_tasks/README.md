# Список задач и краткое описание

1.**Two Sum**

**Задача**: Необходимо найти два числа в списке, которые в сумме равны target

**Решение**: Создаем nums_dict, далее по циклу будем смотреть, есть ли необходимое для суммы 
число (target-nums[i]) в списке? Если да, то ответ найден.
Если нет, то добавляем это число и идем дальше.


3.**Longest Substring Without Repeating Characters**

**Задача**: Дана строка s, найти в ней самую длинную подстроку без повторяющихся символов

**Решение**: 
Заведем переменную max_ans и множество letters_set. Далее заведем указатель l = 0 и будем итерироваться по циклу for r in range(n):

Если текущей буквы s[r] нет в множестве - добавляем, и смотрим, max_ans = max(max_ans, r-l+1)
Если же буква есть в множестве: До тех пор, пока s[r] есть в множестве, удаляем по одной букве из letters_set(s[l]) и двигаем s[l] вперед


20.**Valid Parentheses**

**Задача**: Проверить, является ли скобочная последовательность правильной.

**Решение**: Идем по циклу. Если скобка открывающая - добавляем в open_stack. 
Иначе смотрим: not open_stack (если нечего удалять) или mask_dict[l] (получаем необх. открыв. скобочку) != open_stack.pop(): возвр. False
После цикла возвращаем True, если open_stack пуст


22.**Generate Parentheses**

**Задача**: Сгенерировать все возможные скобочные последовательности ().

**Решение**: 
Напишем функцию get_pairs, куда будет передаваться answer:list, left_count, right_count, cur (текукая последовательность).

Базовый случай рекурсии: if left_count + right_count == 2*n: добавляем последовательность в answer и делаем return.
Потом если left_count < n: вызываем рекурсию, к cur + (, а также left_count+1
Если right_count < left_count: аналогично тексту сверху


23. **Merge k Sorted Lists**

**Задача**: дан список листов. Надо сделать один лист из всех (он должен быть отсортирован).

**Решение**: Добавляем все элементы в кучу. 
Потом heap.heapify(numbers) # преврашаем в кучу
Потом создаем лист: pre_start = ListNode(None),
curr = pre_start

while numbers:
достаем текущее значение из кучи, curr.next = ListNode(val), переносим указатель на curr=curr.next


42. **Trapping Rain Water**

**Задача**: Дан массив с высотами гор на карте. Надо узнать,сколько воды в 'расщелинах' может поместиться.

**Решение**: Заведем 2 указателя: l = 0, r = len(arr) - 1. Также заведем две переменные: max_l и max_r
Теперь, пока l>=r будем смотреть, у кого высота встречалась больше: у левой стороны или у правой.

Если у левой: к ответу приписываем минимум высот минус высота height[r], r уменьшаем на единицу.

Если у правой: также как и у левой, но l += 1, а смотрим height[l]


49.**Group Anagrams**

**Задача**: Дан список строк `strs`.  Необходимо вернуть список списков таких строк, чьи анаграммы совпадают. 

**Решение**: 
Заведем словарь. Дальше делаем цикл и итетирируемся по строкам. Если ''.join(sorted(word)) нет в словаре - добавляем само слово.



56.**Merge Intervals**

**Задача**: Дан список интервалов [[x1,y1], ..]. Необходимо объединить пересекающиеся интервалы. 

**Решение**: Для начала отсортируем все интервалы. Потом зададим начальную переменную new_point = intervals[0].

После этого итерируемся по всем точкам в intervals: Если new_point[1] (координата y) >= new_point[i][0], то пересоздаем new_point = [new_point[0], max(new_point[1], intervals[i][1])]. Если условие не сработало - записываем new_point в ответ и new_point = intervals[i].
В самом конце надо не забыть добавить new_point в ответ.

71.**Simplify Path**

**Задача**: Дана строка - некоторый путь в UNIX-системе. Необходимо превратить её в правильную строку. 

**Задача**: Для начала  разделим path.split('/'), чтобы получить каждый элемент отдельно.

После этого итетируемся по получившемуся массиву:
Если элемент not in ['.', '', '..'] - добавлем в список ответов my_dir

Если элемент == .. и my_dir непуст:
Удаляем из my_dir элемент (my_dir.pop())

Выводим ответ '/' + '/'.join(my_dir)

76.**Minimum Window Substring**

**Задача**: Дано две строки s и t. Необходимо вывести подстроку минимальной длины из s, в которой содержится каждый символ из t.

**Решение**: 
Для начала подсчитаем в списке letters_dict, сколько раз встречались буквы в списке t.

Потом уже в новом списке будем идти по буквам s и если встретили букву из списка t - убавлять её значение на 1.

Если вдруг count(количество необходимым букв) стало равно нулю, то сохраняем значение в answer, если оно максимально. Также пока count == 0 удаляем буквы (плюсуем обратно), одновременно двигая указатель l

