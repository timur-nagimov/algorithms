# Список задач и краткое описание

1.**Two Sum**

**Задача**: Необходимо найти два числа в списке, которые в сумме равны target

**Решение**: Создаем nums_dict, далее по циклу будем смотреть, есть ли необходимое для суммы 
число (target-nums[i]) в списке? Если да, то ответ найден.
Если нет, то добавляем это число и идем дальше.


3.**Longest Substring Without Repeating Characters**

**Задача**: Дана строка s, найти в ней самую длинную подстроку без повторяющихся символов

**Решение**: 
Заведем переменную max_ans и множество letters_set. Далее заведем указатель l = 0 и будем итерироваться по циклу for r in range(n):

Если текущей буквы s[r] нет в множестве - добавляем, и смотрим, max_ans = max(max_ans, r-l+1)
Если же буква есть в множестве: До тех пор, пока s[r] есть в множестве, удаляем по одной букве из letters_set(s[l]) и двигаем s[l] вперед


20.**Valid Parentheses**

**Задача**: Проверить, является ли скобочная последовательность правильной.

**Решение**: Идем по циклу. Если скобка открывающая - добавляем в open_stack. 
Иначе смотрим: not open_stack (если нечего удалять) или mask_dict[l] (получаем необх. открыв. скобочку) != open_stack.pop(): возвр. False
После цикла возвращаем True, если open_stack пуст


22.**Generate Parentheses**

**Задача**: Сгенерировать все возможные скобочные последовательности ().

**Решение**: 
Напишем функцию get_pairs, куда будет передаваться answer:list, left_count, right_count, cur (текукая последовательность).

Базовый случай рекурсии: if left_count + right_count == 2*n: добавляем последовательность в answer и делаем return.
Потом если left_count < n: вызываем рекурсию, к cur + (, а также left_count+1
Если right_count < left_count: аналогично тексту сверху


23. **Merge k Sorted Lists**

**Задача**: дан список листов. Надо сделать один лист из всех (он должен быть отсортирован).

**Решение**: Добавляем все элементы в кучу. 
Потом heap.heapify(numbers) # преврашаем в кучу
Потом создаем лист: pre_start = ListNode(None),
curr = pre_start

while numbers:
достаем текущее значение из кучи, curr.next = ListNode(val), переносим указатель на curr=curr.next


42. **Trapping Rain Water**

**Задача**: Дан массив с высотами гор на карте. Надо узнать,сколько воды в 'расщелинах' может поместиться.

**Решение**: Заведем 2 указателя: l = 0, r = len(arr) - 1. Также заведем две переменные: max_l и max_r
Теперь, пока l>=r будем смотреть, у кого высота встречалась больше: у левой стороны или у правой.

Если у левой: к ответу приписываем минимум высот минус высота height[r], r уменьшаем на единицу.

Если у правой: также как и у левой, но l += 1, а смотрим height[l]


49.**Group Anagrams**

**Задача**: Дан список строк `strs`.  Необходимо вернуть список списков таких строк, чьи анаграммы совпадают. 

**Решение**: 
Заведем словарь. Дальше делаем цикл и итетирируемся по строкам. Если ''.join(sorted(word)) нет в словаре - добавляем само слово.



56.**Merge Intervals**

**Задача**: Дан список интервалов [[x1,y1], ..]. Необходимо объединить пересекающиеся интервалы. 

**Решение**: Для начала отсортируем все интервалы. Потом зададим начальную переменную new_point = intervals[0].

После этого итерируемся по всем точкам в intervals: Если new_point[1] (координата y) >= new_point[i][0], то пересоздаем new_point = [new_point[0], max(new_point[1], intervals[i][1])]. Если условие не сработало - записываем new_point в ответ и new_point = intervals[i].
В самом конце надо не забыть добавить new_point в ответ.

71.**Simplify Path**

**Задача**: Дана строка - некоторый путь в UNIX-системе. Необходимо превратить её в правильную строку. 

**Задача**: Для начала  разделим path.split('/'), чтобы получить каждый элемент отдельно.

После этого итетируемся по получившемуся массиву:
Если элемент not in ['.', '', '..'] - добавлем в список ответов my_dir

Если элемент == .. и my_dir непуст:
Удаляем из my_dir элемент (my_dir.pop())

Выводим ответ '/' + '/'.join(my_dir)

76.**Minimum Window Substring**

**Задача**: Дано две строки s и t. Необходимо вывести подстроку минимальной длины из s, в которой содержится каждый символ из t.

**Решение**: 
Для начала подсчитаем в списке letters_dict, сколько раз встречались буквы в списке t.

Потом уже в новом списке будем идти по буквам s и если встретили букву из списка t - убавлять её значение на 1.

Если вдруг count(количество необходимым букв) стало равно нулю, то сохраняем значение в answer, если оно максимально. Также пока count == 0 удаляем буквы (плюсуем обратно), одновременно двигая указатель l

88.**Merge Sorted Array**

**Задача**: Дано два массива. Объединить in-place

**Решение**: Один указатель на конец первого, второй на конец второго, третий на ту позицию, куда вставляем элемент.

Если arr2[n] >= arr1[m] (n,m длины второго и первых массивов соответственно.) - вставляем элемент на позицию pos, n -= 1.

Иначе:  arr1[pos] = arr1[m]. Потом m-=1.
После всех условий pos -= 1.

Вся фишка в условии >= вначале.

125.**Valid Palindrome**

**Задача**: проверить, является ли строка палиндромом

Тут все понятно. Самое главное сделать вначале:

`s = ''.join(l for l in s if l.isalnum())`

`s = s.lower()`

136.**Single Number**

***Задача***: Найти в списке число, которое встречалось ровно 1 раз.

Операция XOR (^) по всем числам позволяет найти то число, которое встречалось только 1 раз. 0 XOR число - число.

число1 XOR число1 - ноль.

XOR - ассоциативная и коммутативная операция, т.е (a XOR b) XOR c = a XOR (c XOR b). Поэтому независимо от порядка расположения чисел мы всегда доберемся до ответа.

150.**Evaluate Reverse Polish Notation**

**Задача**: Дана запись в польской нотации. Подсчитать итоговое число

**Решение**: Надо использовать стек и собирать туда числа. Когда встречается операция - доставать 2 числа и производить эту операцию. Получившиеся число кладем обратно.

155. **Min Stack**

**Задача**: Написать стек который за O(1) может сказать мин. элемент.

**Решение**: Будет стек на двух стеках: При добавлении элемента добавляем элемент в min_stack если он пуст, если нет то добавляем тот элемент, который меньше: на вершине стека или тот который получили.

161. **One Edit Distance**

**Задача**: Проверить, можно ли одной операцией вставки, удаления, замены получить из строки s строку t.

**Решение**: if s[i+1:] != t[i+1:] and s[i+1:] != t[i:] and s[i:] != t[i+1:]:
                    return False

200. **Numbers of Islands**

**Задача**: Подсчитать число островов

**Решение**: DFS по [i, j+1], [i, j-1], [i+1, j], [i-1, j]. В mainDFS при встрече '1' будем увеличивать счетчик и запускать эту функцию. Она меняет все '1' на '0'.


205.**Isomorphic Strings**

**Задача**: Проверить, можно ли одну строку 'отобразить' в другую.

**Решение**: Иду по циклу. Если s[i] нет в s_isomorphia, то добавляю туда s[i] -> t[i]
Если t[i] нет в t_isomorphia, то добавляю туда t[i] -> s[i]

Смотрю, если s_isomoprhia[s[i]] != t[i] or t_isomorphia[t[i]] != s[i]: return False

228. **Summary Ranges**

**Задача**: Вернуть минимальный отсортированный список

**Решение**: Склеиваем пока arr[r] +1 == arr[r+1]

После цикла также надо склеить то, что осталось.

283. **Move Zeroes**

**Задача**: Дан массив чисел, содержащий нули. Необходимо переместить нули в конец массива, сохранив при этом относительный порядок элементов.

**Решение**: Заведем указатель l, указателем r будем идти по массиву. Если встретившиеся число != 0 - меняем его местами с arr[l]. 


340.Longest substring with at most K distinct characters.

**Задача**: Дана строка s и число k. Надо найти такую подстроку, где количество уникальных символов не больше k.

**Решение**: Идем по строке и добавляем символы. Если len(my_dict.keys()) > k - минусуем и в случае равенства нулю удаляем символ на позиции l. l += 1


356.Line Reflection

**Задача**: Посмотреть, все ли точки в списке делятся одной линией

**Решение**: 

Создадим словарь, пусть координата x будет ключом. По ключу будет множество set, где хранятся все x по y.

Объявляем line_min = line_max = line = None

В цикле по всем ключам: берем min(x_values), max(x_values).
line в таком случае равен (line_max + line_min) / 2

Потом смотрим, для всех ли точек такая линия подходит:
x = x_values.pop()
dist_to_opposite = abs(x-line) - расстояние до нужной точки.

if x > line:
opposite_x = line - dist_to_opposite, иначе если x < line line + dist_to_opposite, иначе пропускаем т.к точке на линии не нужна другая.

Смотрим, если opposite_x not in x_values: return False

Если условие выше не сработало, удаляем противоположную точку, т.к мы её уже посмотрели.

380. **Insert Delete GetRandom O(1)**

**Задача**: сделать set() с получением рандомного элемента за O(1).

**Решение**: set() будет написан на словаре. Если операция pop() - 380. return random.choice(list(self.set_dict.keys()))


443. **String Compression
**
**Задача**: Дана строка. Надо Склеить в ней повторяющиеся символы.

**Решение**: Идем по всем символам while i < n. Записываем текущую букву и идем вперед до тех пор, пока буквы совпадают. 

После того как перестали, на позицию chars[ans] записываем букву, ans += 1. Смотрим, если let_count (кол-во совпад. символов) > 1: делаем цикл по str(let_count). Записываем на позицию ans текущий разряд числа, ans += 1, и т.д..

487.**Max Consecutive Ones II**

**Задача**: дан список чисел 1 и 0. Можно заменить одно число 0 на число 1. Надо вывести размер максимального подмассива, где встречаются только единицы

Решение: Создадим переменные ans, can_change, l и zero_pos. По циклу идем до конца массива. Если впервые встретили 0 - проверяем на макс. размер и записываем, что can_change = False и zero_pos = r. Если же встретили 1 - просто смотрим макс. ли размер. В противном случае, когда поменять уже не можем и встретили ноль: записываем, что l равен zero_pos + 1 - позиция после первого встрет. нуля, а сама zero_pos = r (текущий ноль)


560.Subarray Sum Equals K

**Задача**: Дан массив nums и число k. Вернуть число таких подмассивов, сумма которых равна k.

**Решение**: 
Заводим переменную pref_sum, а также словарь prev_sums. В этмо словаре помечаем, что pref_sum = 0 уже встречалась 1 раз (т.к 0 есть изначально).

Далее, идя по циклу: прибавляем в pref_sum текущее число. В ответ записываем prev_sums.get(pref_sum-k, 0) - можем ли мы таким подмассивом получить число k.

потом для pref_sum - записываем в словарь и прибавляем 1 (встречалась на 1 раз больше).


Словарь `prev_sums` записывает, сколько раз каждое значение префиксной суммы встречалось до текущего индекса. Каждый раз, когда мы находим в `prev_sums` значение \( \text{pref\_sum}[i] - k \), это значит, что существует не один, а несколько начальных индексов \( j \), таких что от \( j+1 \) до \( i \) сумма элементов равна \( k \). Количество таких начальных индексов \( j \) и есть значение по ключу \( \text{pref\_sum}[i] - k \) в словаре `prev_sums`.

Таким образом, `prev_sums` не просто отслеживает предыдущие значения префиксных сумм, он фактически подсчитывает, сколько раз каждый возможный "стартовый индекс" подмассива с нужной суммой мог появиться в массиве до текущего момента, что позволяет точно и эффективно определить количество всех подмассивов с суммой \( k \).

658. **Find K Closest Elements**

лень писать, бинарный поиск без abs(), r задается как len(arr) - k



849. Maximize Distance to Closest Person

**Задача**: Дан список 1 и 0. 0 если кресло свободно, 1 если занято. Найти такое кресло, где расстояние до ближайшего соседа будет максимально.

**Решение**: Используем преф. и суф. суммы. 

Расстояние до соседа слева:
 (if seats[i] == 0)
pref_dist[i+1] = pref_dist[i] + 1

Расстояние до соседа справа: (if seats[i] == 0)
suf_dist[i] = suf_dist[i + 1] + 1

Записываем в max_ans временный ответ: расстояние на краях pref_dist[n] и sum_dist[0]

Потом уже ищем более подходящие варианты:

max_ans = max(max_ans, min(pref_dist[i + 1], suf_dist[i]))

1004. **Max Consecutive Ones III**

**Задача**: Дан список из нулей и единиц, а также число k, которое показывает, сколько нулей мы можем заменить в исходном массиве, чтобы получить макс.длинный подмассив только из единиц.

**Решение**: аналогично для 1 замены, только здесь переменная: пока k больше 0 - считаем макс. расстояние. Если меньше - переносим l и возвращаем возможность замены (cur_changes + 1).