# Чтобы не ходить по графу вечно надо запоминать, какие вершины уже посещены и обработаны.
# Обычно для этого вершины красят в три цвета: белый, серый, черный
# Изначально все вершины белые. Когда DFS впервые заходит в вершину, она становится серой. В дальнейшем она будет покрашена в черный.
#   * белый - вершина не посещена
#   * серый - вершина посещена, но еще не до конца обработана (не вернулись из рекурсии)
#   * черный - вершина посещена и обработка (происходит, когда все её смежные вершины посещены и обработаны)


"""
    Алгоритм DFS (обход в глубину)
    
    Этот алгоритм может обойти не все вершины. Т.к граф может быть несвязным, алгоритм всякий раз выбирает соседние вершины, 
    а в процессе его работы будут посещены вершины одной связной компоненты
    Для ориентированного графа алгоритм посетит и того меншье - только вершины, достижимые из стартовой вершины.
    
    Значит, после того как рекурсивный вызов завершил работу, необходимо выбрать следующую непосещенную, то есть белую, вершину и снова вызвать алгоритм обхода.
    Удобно представить в виде двух функций: рекурсивная и нерекурсивая, которая запускает первую несколько раз.
    
    Сам алгоритм:
        * В цикле, пока остались непосещённые вершины:
            * Выбираем еще не посещенную вершину v
            * Запускаем DFS(v)
        
        * DFS(v) делает следующее:
            * Помечает v как посещенную, но еще не обработанную - серым цветом
            * Рекурсивно запускает DFS(w) для каждой вершины (w), к которой есть ребро из v
            * Когда смежные вершины обработаны, помечает v как обработанную, то есть черным цветом.
"""
# Сложность DFS:
# Если задан матрицей смежности - O(V^2), т.к для каждой из V вершин надо выполнить V операций.
# Если списком смежности - O(V+E)

color = ['white', 'white', ...]

# v - номер вершины


def DFS(v):
    color[v] = 'gray'  # вершина посещена, но не обработана
    for w in outgoing_edges[v]:  # список исходящих ребер
        if color[w] == 'white':
            DFS(w)
    color[v] = 'black'


def mainDFS():
    for i in range(len(color)):
        if color[i] == 'white':
            DFS(i)


# НЕРЕКУРСИВНЫЙ DFS
def DFS(start_vertex):
    stack = []
    stack.append(start_vertex)  # стартовая вершина

    # Пока стек не пуст:
    # Получаем из стека очередную вершину. Она может быть как новой, так и уже посещенной.
    while stack:
        v = stack.pop()

        # красим в серый и кладем обратно в стек.
        # это позволит алгоритму позднее вспомнить обратный путь по графу.
        if color[v] == 'white':
            color[v] = 'grey'
            stack.append(v)

            # теперь добавляем в стек все непосещенные соседние вершины
            # вместо вызова рекурсии
            for w in outgoing_edges[v]:
                if color[w] == 'white':
                    stack.append(w)
        elif color[v] == 'gray':
            color[v] = 'black'
